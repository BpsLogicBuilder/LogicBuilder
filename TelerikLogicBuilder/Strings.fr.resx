<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="applicationNameLogicBuilder" xml:space="preserve">
    <value>BPS Logic BuilderFR</value>
  </data>
	<data name="applicationNameFormat" xml:space="preserve">
    <value>App{0}FR</value>
    <comment>0=Count</comment>
  </data>
	<data name="assemblyUnavailableMessageFormat" xml:space="preserve">
    <value>The assembly "{0}", one of its dependencies or the class "{1}" could not be loaded.FR</value>
    <comment>0=assemblyFullPath; 1=FullyQulifiedClassName</comment>
  </data>
	<data name="binaryOperatorCodeNameInvalidFormat" xml:space="preserve">
    <value>Invalid Member Name "{0}" for Binary Operator "{1}". Valid code names are: {2}.FR</value>
    <comment>0=Member Name; 1=Function; 2=List of valid names</comment>
  </data>
	<data name="builtInFunctionNameAnd" xml:space="preserve">
    <value>AndFR</value>
  </data>
	<data name="builtInFunctionNameChainingUpdate" xml:space="preserve">
    <value>ChainingUpdateFR</value>
  </data>
	<data name="builtInFunctionNameEquals" xml:space="preserve">
    <value>EqualsFR</value>
  </data>
	<data name="builtInFunctionNameGreaterThan" xml:space="preserve">
    <value>Greater ThanFR</value>
  </data>
	<data name="builtInFunctionNameGreaterThanOrEquals" xml:space="preserve">
    <value>Greater Than or EqualsFR</value>
  </data>
	<data name="builtInFunctionNameLessThan" xml:space="preserve">
    <value>Less ThanFR</value>
  </data>
	<data name="builtInFunctionNameLessThanOrEquals" xml:space="preserve">
    <value>Less Than or EqualsFR</value>
  </data>
	<data name="builtInFunctionNameNot" xml:space="preserve">
    <value>NotFR</value>
  </data>
	<data name="builtInFunctionNameRemoveDecision" xml:space="preserve">
    <value>Set To NullFR</value>
  </data>
	<data name="builtInFunctionNameSetDecision" xml:space="preserve">
    <value>Set VariableFR</value>
  </data>
	<data name="builtInFunctionNameOr" xml:space="preserve">
    <value>OrFR</value>
  </data>
	<data name="builtInFunctionsRootFolderText" xml:space="preserve">
    <value>Built In FunctionsFR</value>
  </data>
	<data name="builtInParameterNameValue" xml:space="preserve">
    <value>valueFR</value>
  </data>
	<data name="builtInParameterNameValue1" xml:space="preserve">
    <value>value1FR</value>
  </data>
	<data name="builtInParameterNameValue2" xml:space="preserve">
    <value>value2FR</value>
  </data>
	<data name="builtInParameterNameVariable" xml:space="preserve">
    <value>VariableFR</value>
  </data>
	<data name="cannotEvaluateVariableFormat" xml:space="preserve">
    <value>Type cannot be evaluated. Variable "{0}" is not configured.FR</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="cannotLoadAssemblyFormat" xml:space="preserve">
    <value>Assembly "{0}" could not be loaded.FR</value>
    <comment>0=Assembly</comment>
  </data>
	<data name="cannotLoadCastAsVariableTypeFormat" xml:space="preserve">
    <value>Cannot load "Cast Variable As" type "{0}" for the variable "{1}".FR</value>
    <comment>0=castAsTypeName; 1=variableName;</comment>
  </data>
	<data name="cannotLoadClassFormat" xml:space="preserve">
    <value>Class "{0}" could not be loaded.FR</value>
    <comment>0=ActivityClass</comment>
  </data>
	<data name="cannotLoadPropertySourceParameterFormat" xml:space="preserve">
    <value>Cannot find the required property sourced parameter "{0}" for the parameter "{1}" in constructor "{2}". The property sourced parameter must be one of the sibling parameters {3} when the control is {4}.FR</value>
    <comment>0=sourceParameter; 1=parameter; 2=constructor;3=SiblingParameterList; 4=ParameterSourcedProperyInputText</comment>
  </data>
	<data name="cannotLoadTypeForConstructorFormat" xml:space="preserve">
    <value>Type "{0}" could not be loaded for the constructor "{1}".FR</value>
    <comment>0=typeName;1=constructorName</comment>
  </data>
	<data name="cannotLoadTypeForFunctionFormat" xml:space="preserve">
    <value>The return type "{0}" could not be loaded for the function "{1}".FR</value>
    <comment>0=typeName;1=functionName</comment>
  </data>
	<data name="cannotLoadTypeForGenericArgumentForConstructorFormat" xml:space="preserve">
    <value>Cannot load the type for the generic argument "{0}". Constructor name: {1}.FR</value>
    <comment>0=generic argument name;1=constructor name</comment>
  </data>
	<data name="cannotLoadTypeForGenericArgumentForFunctionFormat" xml:space="preserve">
    <value>Cannot load the type for the generic argument "{0}". Function name: {1}.FR</value>
    <comment>0=generic argument name;1=function name</comment>
  </data>
	<data name="cannotLoadTypeFormat2" xml:space="preserve">
    <value>Cannot load the type "{0}".FR</value>
    <comment>0=typeName;</comment>
  </data>
	<data name="cannotLoadTypeForVariableFormat" xml:space="preserve">
    <value>The variable type "{0}" could not be loaded for the variable "{1}".FR</value>
    <comment>0=typeName;1=variableName</comment>
  </data>
	<data name="castReferenceAsMustBeEmptyFormat" xml:space="preserve">
    <value>Cast Reference As field for variable {0} must be empty when the reference category is "This" or reference category is "Type".FR</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="chainingUpdateValidationError" xml:space="preserve">
    <value>The field or property to be updated must be represented by a string and cannot include functions or variables.FR</value>
  </data>
	<data name="connectorCategoryUndefinedFormat" xml:space="preserve">
    <value>The connector category {0} is undefined.FR</value>
    <comment>0=connector category</comment>
  </data>
	<data name="constrGenericArgNameInvalidFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for generic parameter "{1}" in constructor "{2}" is invalid.  Generic argument names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.FR</value>
    <comment>0=genericArgumentName;1=parameterName;2=constructorName</comment>
  </data>
	<data name="constructorGenericArgsMisMatchFormat" xml:space="preserve">
    <value>The configured constructor's generic arguments "{0}" must match the data's generic arguments "{1}".FR</value>
    <comment>0=constructor's generic arguments;1= data's generic arguments</comment>
  </data>
	<data name="constructorGenericArgsMisMatchFormat2" xml:space="preserve">
    <value>The configured constructor's type name  "{0}" must be a generic type definition matching the generic arguments "{1}".FR</value>
    <comment>0=constructor's type name;1= data's generic arguments</comment>
  </data>
	<data name="constructorNotAssignableFormat" xml:space="preserve">
    <value>The constructor "{0}" must be assignable to "{1}".FR</value>
    <comment>0=constructorName;1=objectType</comment>
  </data>
	<data name="constructorNotConfiguredForObjectTypeFormat" xml:space="preserve">
    <value>There is no constructor configured for the object type "{0}".FR</value>
    <comment>0=typeName</comment>
  </data>
	<data name="constructorNotConfiguredForObjectTypeFormat2" xml:space="preserve">
    <value>The constructor "{0}" cannot be assigned to the object type "{1}".FR</value>
    <comment>0=constructorName;1=typeName</comment>
  </data>
	<data name="constructorsRootFolderText" xml:space="preserve">
    <value>ConstructorsFR</value>
  </data>
	<data name="constructorToStringFormat" xml:space="preserve">
    <value>{0} - {1}({2})FR</value>
    <comment>0=constructorName 1=Type 2=parametersToString</comment>
  </data>
	<data name="createNewConstructorsFileQuestion" xml:space="preserve">
    <value>Create a new Constructors File?FR</value>
  </data>
	<data name="createNewFragmentsFileQuestion" xml:space="preserve">
    <value>Create a new Fragments File?FR</value>
  </data>
	<data name="createNewFunctionsFileQuestion" xml:space="preserve">
    <value>Create a new Functions File?FR</value>
  </data>
	<data name="createNewProjectFileQuestion" xml:space="preserve">
    <value>Create a new Project File?FR</value>
  </data>
	<data name="createNewVariablesFileQuestion" xml:space="preserve">
    <value>Create a new Variables File?FR</value>
  </data>
	<data name="defaultActivityAssemblyFolder" xml:space="preserve">
    <value>ActivityAssemblyFR</value>
  </data>
	<data name="defaultActivityClass" xml:space="preserve">
    <value>ActivityNamespace.ActivityClassFR</value>
  </data>
	<data name="defaultDeleteRulesUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/DeleteRules</value>
  </data>
	<data name="defaultDeleteAllRulesUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/DeleteAllRules</value>
  </data>
	<data name="defaultErrorMessage" xml:space="preserve">
    <value>An error has occurred.FR</value>
  </data>
	<data name="defaultPostFileDataUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/PostFileData</value>
  </data>
	<data name="defaultPostVariableMetaDataUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/PostVariableMetaData</value>
  </data>
	<data name="defaultResourcesFile" xml:space="preserve">
    <value>strings.resourcesFR</value>
  </data>
	<data name="defaultResourcesFolder" xml:space="preserve">
    <value>ResourcesFR</value>
  </data>
	<data name="defaultRulesFile" xml:space="preserve">
    <value>expert.rulesFR</value>
  </data>
	<data name="defaultRulesFolder" xml:space="preserve">
    <value>RulesFR</value>
  </data>
	<data name="dotExe" xml:space="preserve">
    <value>.exe</value>
  </data>
	<data name="fragmentsRootNodeText" xml:space="preserve">
    <value>FragmentsFR</value>
  </data>
	<data name="funcCannotLoadPropertySourceParameterFormat" xml:space="preserve">
    <value>Cannot find the required property sourced parameter "{0}" for the parameter "{1}" in function "{2}". The property sourced parameter must be one of the sibling parameters {3} when the control is {4}.FR</value>
    <comment>0=sourceParameter; 1=parameter; 2=function;3=SiblingParameterList; 4=ParameterSourcedProperyInputText</comment>
  </data>
	<data name="funcGenericArgNameInvalidFormat" xml:space="preserve">
    <value>The generic argument name "{0}" in function "{1}" is invalid.  Generic argument names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.FR</value>
    <comment>0=genericArgumentName;1=parameterName;2=functionName</comment>
  </data>
	<data name="funcGenericArgNotValidForAllReferenceCatFormat" xml:space="preserve">
    <value>Generic arguments are only valid when the reference category is "Type". Function name: "{0}".FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="funcGenericParameterArgNameNotFoundFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for generic parameter "{1}" in function "{2}" is not one of the function's generic arguments: "{3}".FR</value>
    <comment>0=genericArgumentName;1=parameterName;2=functionName;3=listOfGenericArguments</comment>
  </data>
	<data name="funcGenericReturnTypeArgNameNotFoundFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for the return type in function "{1}" is not one of the function's generic arguments: "{2}".FR</value>
    <comment>0=genericArgumentName;1=functionName;2=listOfGenericArguments</comment>
  </data>
	<data name="functionBlankCategoryFormat" xml:space="preserve">
    <value>Reference Category for function "{0}" cannot be empty.FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionGenericArgsMisMatchFormat" xml:space="preserve">
    <value>The configured function's generic arguments "{0}" must match the data's generic arguments "{1}".FR</value>
    <comment>0=function's generic arguments;1= data's generic arguments</comment>
  </data>
	<data name="functionGenericArgsMisMatchFormat2" xml:space="preserve">
    <value>The configured function's reference category must be "{0}", and the type name "{1}" must be a generic type definition matching the generic arguments "{2}".FR</value>
    <comment>0reference category;1=function's type name;1= data's generic arguments</comment>
  </data>
	<data name="functionInvalidCategoryFormat" xml:space="preserve">
    <value>Function "{0}" has invalid Reference Category "{1}". Valid categories are:{2}{3}FR</value>
    <comment>0=functionName; 1=Referencecategory; 2=Environment.Newline; 3=ValidCategories</comment>
  </data>
	<data name="functionInvalidIndirectDefinitionFormat" xml:space="preserve">
    <value>Function "{0}" has invalid section "{1}" in its Reference Definition Field. Valid sections for indirect references include:{2}{3}FR</value>
    <comment>0=functionName; 1=ReferenceDefinition; 2=Environment.Newline; 3=ValidDefinitionList</comment>
  </data>
	<data name="functionNameAndCastAsFormat" xml:space="preserve">
    <value>Function "{0}". When it is not empty, Cast Reference As and Reference Name must have an equal number of sections when the function is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.0.boz, Cast Reference As = ~.~.~."MyNameSpace.MyClass" (Use a tilde (~) where a cast is not needed. Use quotes as a text qualifier when the fully qualified class name contains a period).FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionNameAndDefinitionFormat" xml:space="preserve">
    <value>Function "{0}". Reference Name and Reference Definition must have an equal number of sections when the function is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.0.boz, Reference Definition = Field.Property.IntKeyValue.Field.FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionNotAssignableFormat" xml:space="preserve">
    <value>The function "{0}" must be assignable to "{1}".FR</value>
    <comment>0=functionName;1=objectType</comment>
  </data>
	<data name="functionNotConfiguredFormat" xml:space="preserve">
    <value>Function "{0}" is not configured.FR</value>
    <comment>0=FunctionName</comment>
  </data>
	<data name="functionReferenceInfoMustBePopulatedFormat" xml:space="preserve">
    <value>Reference Name and Reference Definition field for function {0} must be populated when the reference category is "Instance Reference" or reference category is "Static Reference".FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionReferenceMustBeEmptyFormat" xml:space="preserve">
    <value>Reference Name field for function {0} must be empty when the reference category is "This", "Type" or "None".FR</value>
  </data>
	<data name="functionsRootFolderText" xml:space="preserve">
    <value>FunctionsFR</value>
  </data>
	<data name="functionToStringFormat" xml:space="preserve">
    <value>{0} - {1}({2})FR</value>
    <comment>0=functionName 1=Type 2=parametersToString</comment>
  </data>
	<data name="functionTypeNameMustBeEmptyFormat" xml:space="preserve">
    <value>Type Name field for function {0} must be empty when the reference category is not "Type"or "Static Reference".FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="genericMethodsNotSupportedFormat" xml:space="preserve">
    <value>Generic methods are not supported. Method name: "{0}".FR</value>
    <comment>0=methodName</comment>
  </data>
	<data name="genericParameterArgNameNotFoundFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for generic parameter "{1}" in constructor "{2}" is not one of the constructor's generic arguments: "{3}".FR</value>
    <comment>0=genericArgumentName;1=parameterName;2=constructorName;3=listOfGenericArguments</comment>
  </data>
	<data name="invalidAnyParameterConfigurationForBinaryOperatorFormat" xml:space="preserve">
		<value>For the binary operator "{0}", both parameters can be of literal type "Any" or neither can be of literal type "Any". First parameter: "{1}", second parameter: "{2}".FR</value>
	</data>
  <data name="invalidArgumentTextFormat" xml:space="preserve">
    <value>Invalid Argument {0}.FR</value>
  </data>
	<data name="invalidConfigurationDocumentFormat" xml:space="preserve">
    <value>{0} has invalid data.FR</value>
    <comment>{0}=fileFullName</comment>
  </data>
	<data name="invalidConsParameterOrder" xml:space="preserve">
    <value>The parameter order for constructor "{0}" is invalid. Move optional parameters to the end of the parameters list.FR</value>
    <comment>0=FunctionName</comment>
  </data>
	<data name="invalidFunctionCategoryFormat" xml:space="preserve">
    <value>Function "{0}" has invalid function category "{1}" given the element type "{2}".FR</value>
    <comment>0=functionName;1=functionCategory;2=elementName</comment>
  </data>
	<data name="invalidLiteralInputFormat" xml:space="preserve">
    <value>Input "{0}" is invalid for the literal type "{1}"FR.</value>
    <comment>0=input, 1=Type</comment>
  </data>
	<data name="invalidLiteralInputFormat2" xml:space="preserve">
    <value>Input is invalid for the literal type "{0}".FR</value>
    <comment>0=Type</comment>
  </data>
	<data name="invalidParameterElementFormat" xml:space="preserve">
    <value>The parameter "{0}" has an invalid element for the category "{1}".FR</value>
    <comment>0=parameterName;1=parameterCategory;</comment>
  </data>
	<data name="invalidParameterOrder" xml:space="preserve">
    <value>The parameter order for function "{0}" is invalid. Move optional parameters to the end of the parameters list.FR</value>
    <comment>0=FunctionName</comment>
  </data>
	<data name="itemsCommaSeparator" xml:space="preserve">
    <value>, </value>
  </data>
	<data name="listParameterTypeNameFormat" xml:space="preserve">
    <value>{0}Of{1}: {2}FR</value>
    <comment>0=listType 1=UnderlyingType 2=name</comment>
  </data>
	<data name="listDescriptionFormat" xml:space="preserve">
    <value>{0} Of {1}FR</value>
    <comment>0=listType 1=UnderlyingType</comment>
  </data>
	<data name="listVariableTypeFormat" xml:space="preserve">
    <value>{0}Of{1}FR</value>
    <comment>0=listType 1=UnderlyingType</comment>
  </data>
	<data name="memberNameIsInvalidFormat" xml:space="preserve">
    <value>Member Name Field for function {0} is invalid. Variable or function names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="metaObjectRequiredForDialogConnectorsFormat" xml:space="preserve">
    <value>The {0} element is required for dialog connectors.FR</value>
    <comment>0=connector category</comment>
  </data>
	<data name="multipleChoiceParamNotLastFormat" xml:space="preserve">
    <value>Error configuring method {0}. The connectors multiple choice parameter must be the last parameter.FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="neitherOperandCanBeEmptyBinaryOperationAny" xml:space="preserve">
    <value>Neither operand can be empty if 1) the function is a binary operation, 2) parameter type for the operands is Any, and 3) the other operand is not nullable.FR</value>
  </data>
  <data name="notImplementedMessageFormat" xml:space="preserve">
    <value>Method not implemented in {0}.FR</value>
  </data>
	<data name="parameterCountMustBeTwoFormat" xml:space="preserve">
    <value>Because Parameters Layout is Binary, function {0} must have exactly 2 parameters.FR</value>
  </data>
	<data name="parameterNotLiteralFormat" xml:space="preserve">
    <value>The parameter "{0}" of type "{1}" is not a valid literal.FR</value>
  </data>
	<data name="parameterNotOptionalFormat" xml:space="preserve">
    <value>Parameter "{0}" is not optional.FR</value>
  </data>
	<data name="parametersLayoutMustBeBinaryFormat" xml:space="preserve">
    <value>Parameters Layout for function {0} must be "Binary" when the function category is "Binary Operator".FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="parametersNotCompatibleForBinaryOperation" xml:space="preserve">
    <value>The parameter types "{0}" and "{1}" cannot be applied as operands in the binary operation "{2}".FR</value>
  </data>
  <data name="parameterTypeNameFormat2" xml:space="preserve">
    <value>{0}: {1}FR</value>
    <comment>0=type 1=name</comment>
  </data>
	<data name="referenceCannotEqualVariable" xml:space="preserve">
    <value>The variable index cannot be the same as the variable it references. Reference Name: "{0}", variable: "{1}".FR</value>
    <comment>0=referenceName; 1=variableName</comment>
  </data>
	<data name="referenceCategoryCannotBeNoneFormat" xml:space="preserve">
    <value>Reference Category for function {0} cannot be "None" given the function category.FR</value>
  </data>
	<data name="referenceCategoryMustBeNoneFormat" xml:space="preserve">
    <value>Reference Category for function {0} must be "None" when the function category is "Binary Operator".FR</value>
  </data>
	<data name="referenceNameAndCastReferenceAFormat" xml:space="preserve">
    <value>Variable "{0}". When it is not empty, Cast Reference As and Reference Name must have an equal number of sections when the variable is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.1.boz, Cast Reference As = ~.~.~."MyNameSpace.MyClass" (Use a tilde (~) where a cast is not needed. Use quotes as a text qualifier when the fully qualified class name contains a period).FR</value>
    <comment>0=VariableName</comment>
  </data>
  <data name="spaceString" xml:space="preserve">
    <value>&#32;</value>
  </data>
	<data name="truncatedMessageTextFormat" xml:space="preserve">
    <value>{0} ...FR</value>
    <comment>0=truncated message</comment>
  </data>
	<data name="typeReferenceNameIsInvalidFormat" xml:space="preserve">
    <value>Fully Qualified Type Reference Name field for function {0} is invalid. Fully Qualified Class Names must start with an alpha character or underscore and can contain only alphanumeric characters, periods, plus (+) characters and underscores.FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="typeReferenceNameIsInvalidConstructorFormat" xml:space="preserve">
    <value>Fully Qualified Type Reference Name field for constructor {0} is invalid. Fully Qualified Class Names must start with an alpha character or underscore and can contain only alphanumeric characters, periods, plus (+) characters and underscores.FR</value>
    <comment>0=functionName</comment>
  </data>
	<data name="typeReferenceNameIsInvalidFormatVariable" xml:space="preserve">
    <value>Fully Qualified Type Name field for variable {0} is invalid. Fully Qualified Class Names must start with an alpha character or underscore and can contain only alphanumeric characters, periods, plus (+) characters and underscores.FR</value>
    <comment>0=variableName</comment>
  </data>
  <data name="underscore" xml:space="preserve">
    <value>_</value>
  </data>
	<data name="unhandledEventLoggerExceptionFormat" xml:space="preserve">
    <value>The event logger has generated an unhandled exception of type: "{0}". Message: "{1}".FR</value>
  </data>
	<data name="variableBlankCategoryFormat" xml:space="preserve">
    <value>Reference Category for variable "{0}" cannot be empty.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableIndexCannotBeSelfFormat" xml:space="preserve">
    <value>The variable index in the Variable Name field, cannot be used to reference itself. Variable: "{0}".FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableInvalidCategoryFormat" xml:space="preserve">
    <value>Variable "{0}" has invalid Reference Category "{1}". Valid categories are:{2}{3}.FR</value>
    <comment>0=variableName; 1=Referencecategory; 2=Environment.Newline; 3=ValidCategoryList</comment>
  </data>
	<data name="variableInvalidIndirectDefinitionFormat" xml:space="preserve">
    <value>Variable "{0}" has invalid section "{1}" in its Reference Definition Field. Valid sections for indirect references include:{2}{3}.FR</value>
    <comment>0=variableName; 1=ReferenceDefinition; 2=Environment.Newline; 3=ValidDefinitionList</comment>
  </data>
	<data name="variableNameAndDefinitionFormat" xml:space="preserve">
    <value>Variable "{0}". Reference Name and Reference Definition must have an equal number of sections when the variable is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.1.boz, Reference Category = Field.Property.IntKeyValue.Field.FR</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variableNotAssignableFormat" xml:space="preserve">
    <value>The variable "{0}" must be assignable to "{1}".FR</value>
    <comment>0=variableName;1=objectType</comment>
  </data>
	<data name="variableReferenceDefinitionMustBeEmptyFormat" xml:space="preserve">
    <value>Reference Definition field for variable {0} must be empty when the reference category is "This" or reference category is "Type" or the evaluation is "Automatic".FR</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variableReferenceInfoMustBePopulatedFormat" xml:space="preserve">
    <value>Reference Name and Reference Definition field for variable {0} must be populated when the reference category is "Instance Reference" or reference category is "Static Reference".FR</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variableReferenceMustBeEmptyFormat" xml:space="preserve">
    <value>Reference Name field for variable {0} must be empty when the reference category is "This" or reference category is "Type" or the evaluation is "Automatic".FR</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variablesRootNodeText" xml:space="preserve">
    <value>VariablesFR</value>
  </data>
	<data name="variableTypeNameMustBeEmptyFormat" xml:space="preserve">
    <value>Type Name field for  variable {0} must be empty when the reference category is not "Type"or "Static Reference".FR</value>
  </data>
	<data name="enumDescriptionAny" xml:space="preserve">
    <value>AnyFR</value>
  </data>
	<data name="enumDescriptionBoolean" xml:space="preserve">
    <value>BooleanFR</value>
  </data>
	<data name="enumDescriptionDateTime" xml:space="preserve">
    <value>DateTimeFR</value>
  </data>
	<data name="enumDescriptionDateTimeOffset" xml:space="preserve">
    <value>DateTimeOffsetFR</value>
  </data>
	<data name="enumDescriptionDateOnly" xml:space="preserve">
    <value>DateOnlyFR</value>
  </data>
	<data name="enumDescriptionDate" xml:space="preserve">
    <value>DateTimeFR</value>
  </data>
	<data name="enumDescriptionTimeSpan" xml:space="preserve">
    <value>TimeSpanFR</value>
  </data>
	<data name="enumDescriptionTimeOnly" xml:space="preserve">
    <value>TimeOnlyFR</value>
  </data>
	<data name="enumDescriptionTimeOfDay" xml:space="preserve">
    <value>TimeOfDayFR</value>
  </data>
	<data name="enumDescriptionLong" xml:space="preserve">
    <value>LongFR</value>
  </data>
	<data name="enumDescriptionByte" xml:space="preserve">
    <value>ByteFR</value>
  </data>
	<data name="enumDescriptionChar" xml:space="preserve">
    <value>CharFR</value>
  </data>
	<data name="enumDescriptionDouble" xml:space="preserve">
    <value>DoubleFR</value>
  </data>
	<data name="enumDescriptionFloat" xml:space="preserve">
    <value>FloatFR</value>
  </data>
	<data name="enumDescriptionShort" xml:space="preserve">
    <value>ShortFR</value>
  </data>
	<data name="enumDescriptionSByte" xml:space="preserve">
    <value>Signed ByteFR</value>
  </data>
	<data name="enumDescriptionString" xml:space="preserve">
    <value>StringFR</value>
  </data>
	<data name="enumDescriptionUInteger" xml:space="preserve">
    <value>Unsigned IntegerFR</value>
  </data>
	<data name="enumDescriptionULong" xml:space="preserve">
    <value>Unsigned LongFR</value>
  </data>
	<data name="enumDescriptionUShort" xml:space="preserve">
    <value>Unsigned ShortFR</value>
  </data>
	<data name="enumDescriptionGuid" xml:space="preserve">
    <value>GuidFR</value>
  </data>
	<data name="enumDescriptionDecimal" xml:space="preserve">
    <value>DecimalFR</value>
  </data>
	<data name="enumDescriptionInteger" xml:space="preserve">
    <value>IntegerFR</value>
  </data>
	<data name="enumDescriptionNullableDecimal" xml:space="preserve">
    <value>Nullable DecimalFR</value>
  </data>
	<data name="enumDescriptionNullableInteger" xml:space="preserve">
    <value>Nullable IntegerFR</value>
  </data>
	<data name="enumDescriptionNullableBoolean" xml:space="preserve">
    <value>Nullable BooleanFR</value>
  </data>
	<data name="enumDescriptionNullableDateTime" xml:space="preserve">
    <value>Nullable DateTimeFR</value>
  </data>
	<data name="enumDescriptionNullableDateTimeOffset" xml:space="preserve">
    <value>Nullable DateTimeOffsetFR</value>
  </data>
	<data name="enumDescriptionNullableDateOnly" xml:space="preserve">
    <value>Nullable DateOnlyFR</value>
  </data>
	<data name="enumDescriptionNullableDate" xml:space="preserve">
    <value>Nullable DateFR</value>
  </data>
	<data name="enumDescriptionNullableTimeSpan" xml:space="preserve">
    <value>Nullable TimeSpanFR</value>
  </data>
	<data name="enumDescriptionNullableTimeOnly" xml:space="preserve">
    <value>Nullable TimeOnlyFR</value>
  </data>
	<data name="enumDescriptionNullableTimeOfDay" xml:space="preserve">
    <value>Nullable TimeOfDayFR</value>
  </data>
	<data name="enumDescriptionNullableGuid" xml:space="preserve">
    <value>Nullable GuidFR</value>
  </data>
	<data name="enumDescriptionNullableByte" xml:space="preserve">
    <value>Nullable ByteFR</value>
  </data>
	<data name="enumDescriptionNullableShort" xml:space="preserve">
    <value>Nullable ShortFR</value>
  </data>
	<data name="enumDescriptionNullableLong" xml:space="preserve">
    <value>Nullable LongFR</value>
  </data>
	<data name="enumDescriptionNullableFloat" xml:space="preserve">
    <value>Nullable FloatFR</value>
  </data>
	<data name="enumDescriptionNullableDouble" xml:space="preserve">
    <value>Nullable DoubleFR</value>
  </data>
	<data name="enumDescriptionNullableChar" xml:space="preserve">
    <value>Nullable CharFR</value>
  </data>
	<data name="enumDescriptionNullableSByte" xml:space="preserve">
    <value>Nullable SByteFR</value>
  </data>
	<data name="enumDescriptionNullableUShort" xml:space="preserve">
    <value>Nullable UShortFR</value>
  </data>
	<data name="enumDescriptionNullableUInteger" xml:space="preserve">
    <value>Nullable UIntegerFR</value>
  </data>
	<data name="enumDescriptionNullableULong" xml:space="preserve">
    <value>Nullable ULongFR</value>
  </data>
	<data name="enumDescriptionVoid" xml:space="preserve">
    <value>VoidFR</value>
  </data>
	<data name="enumDescriptionArray" xml:space="preserve">
    <value>ArrayFR</value>
  </data>
	<data name="enumDescriptionGenericList" xml:space="preserve">
    <value>Generic ListFR</value>
  </data>
	<data name="enumDescriptionGenericCollection" xml:space="preserve">
    <value>Generic CollectionFR</value>
  </data>
	<data name="enumDescriptionIGenericList" xml:space="preserve">
    <value>Generic List InterfaceFR</value>
  </data>
	<data name="enumDescriptionIGenericCollection" xml:space="preserve">
    <value>Generic Collection InterfaceFR</value>
  </data>
	<data name="enumDescriptionIGenericEnumerable" xml:space="preserve">
    <value>Generic Enumerable InterfaceFR</value>
  </data>
	<data name="enumDescriptionField" xml:space="preserve">
    <value>FieldFR</value>
  </data>
	<data name="enumDescriptionProperty" xml:space="preserve">
    <value>PropertyFR</value>
  </data>
	<data name="enumDescriptionInstanceReference" xml:space="preserve">
    <value>Instance ReferenceFR</value>
  </data>
	<data name="enumDescriptionStaticReference" xml:space="preserve">
    <value>Static ReferenceFR</value>
  </data>
	<data name="enumDescriptionNone" xml:space="preserve">
    <value>NoneFR</value>
  </data>
	<data name="enumDescriptionThis" xml:space="preserve">
    <value>ThisFR</value>
  </data>
	<data name="enumDescriptionType" xml:space="preserve">
    <value>TypeFR</value>
  </data>
	<data name="enumDescriptionArrayIndexer" xml:space="preserve">
    <value>ArrayItemFR</value>
  </data>
	<data name="enumDescriptionIntegerKeyIndexer" xml:space="preserve">
    <value>IntKeyValueFR</value>
  </data>
	<data name="enumDescriptionStringKeyIndexer" xml:space="preserve">
    <value>StringKeyValueFR</value>
  </data>
	<data name="enumDescriptionBooleanKeyIndexer" xml:space="preserve">
    <value>BoolKeyValueFR</value>
  </data>
	<data name="enumDescriptionByteKeyIndexer" xml:space="preserve">
    <value>ByteKeyValueFR</value>
  </data>
	<data name="enumDescriptionCharKeyIndexer" xml:space="preserve">
    <value>CharKeyValueFR</value>
  </data>
	<data name="enumDescriptionDateTimeKeyIndexer" xml:space="preserve">
    <value>DateTimeKeyValueFR</value>
  </data>
	<data name="enumDescriptionDateTimeOffsetKeyIndexer" xml:space="preserve">
    <value>DateTimeOffsetKeyValueFR</value>
  </data>
	<data name="enumDescriptionDateOnlyKeyIndexer" xml:space="preserve">
    <value>DateOnlyKeyValueFR</value>
  </data>
	<data name="enumDescriptionDateKeyIndexer" xml:space="preserve">
    <value>DateKeyValueFR</value>
  </data>
	<data name="enumDescriptionTimeSpanKeyIndexer" xml:space="preserve">
    <value>TimeSpanKeyValueFR</value>
  </data>
	<data name="enumDescriptionTimeOnlyKeyIndexer" xml:space="preserve">
    <value>TimeOnlyKeyValueFR</value>
  </data>
	<data name="enumDescriptionTimeOfDayKeyIndexer" xml:space="preserve">
    <value>TimeOfDayKeyValueFR</value>
  </data>
	<data name="enumDescriptionGuidKeyIndexer" xml:space="preserve">
    <value>GuidKeyValueFR</value>
  </data>
	<data name="enumDescriptionDecimalKeyIndexer" xml:space="preserve">
    <value>DecimalKeyValueFR</value>
  </data>
	<data name="enumDescriptionDoubleKeyIndexer" xml:space="preserve">
    <value>DoubleKeyValueFR</value>
  </data>
	<data name="enumDescriptionFloatKeyIndexer" xml:space="preserve">
    <value>FloatKeyValueFR</value>
  </data>
	<data name="enumDescriptionLongKeyIndexer" xml:space="preserve">
    <value>LongKeyValueFR</value>
  </data>
	<data name="enumDescriptionSByteKeyIndexer" xml:space="preserve">
    <value>SByteKeyValueFR</value>
  </data>
	<data name="enumDescriptionShortKeyIndexer" xml:space="preserve">
    <value>ShortKeyValueFR</value>
  </data>
	<data name="enumDescriptionUIntegerKeyIndexer" xml:space="preserve">
    <value>UIntKeyValueFR</value>
  </data>
	<data name="enumDescriptionULongKeyIndexer" xml:space="preserve">
    <value>ULongKeyValueFR</value>
  </data>
	<data name="enumDescriptionUShortKeyIndexer" xml:space="preserve">
    <value>UShortKeyValueFR</value>
  </data>
	<data name="enumDescriptionVariableKeyIndexer" xml:space="preserve">
    <value>VariableKeyValueFR</value>
  </data>
	<data name="enumDescriptionVariableArrayIndexer" xml:space="preserve">
    <value>VariableKeyArrayItemFR</value>
  </data>
	<data name="enumDescriptionDropDown" xml:space="preserve">
    <value>DropDownFR</value>
  </data>
	<data name="enumDescriptionMultipleLineTextBox" xml:space="preserve">
    <value>Multiple Line Text boxFR</value>
  </data>
	<data name="enumDescriptionSingleLineTextBox" xml:space="preserve">
    <value>Single Line Text boxFR</value>
  </data>
	<data name="enumDescriptionTypeAutoComplete" xml:space="preserve">
    <value>Type Auto CompleteFR</value>
  </data>
	<data name="enumDescriptionDomainAutoComplete" xml:space="preserve">
    <value>Domain Auto CompleteFR</value>
  </data>
	<data name="enumDescriptionPropertyInput" xml:space="preserve">
    <value>Property InputFR</value>
  </data>
	<data name="enumDescriptionParameterSourcedPropertyInput" xml:space="preserve">
    <value>Parameter Sourced Property InputFR</value>
  </data>
	<data name="enumDescriptionParameterSourceOnly" xml:space="preserve">
    <value>Parameter Source OnlyFR</value>
  </data>
	<data name="enumDescriptionLiteral" xml:space="preserve">
    <value>LiteralFR</value>
  </data>
	<data name="enumDescriptionObject" xml:space="preserve">
    <value>ObjectFR</value>
  </data>
	<data name="enumDescriptionGeneric" xml:space="preserve">
    <value>GenericFR</value>
  </data>
	<data name="enumDescriptionLiteralList" xml:space="preserve">
    <value>Literal ListFR</value>
  </data>
	<data name="enumDescriptionObjectList" xml:space="preserve">
    <value>Object ListFR</value>
  </data>
	<data name="enumDescriptionListForm" xml:space="preserve">
    <value>List FormFR</value>
  </data>
	<data name="enumDescriptionHashSetForm" xml:space="preserve">
    <value>Hash Set FormFR</value>
  </data>
	<data name="enumDescriptionConnectors" xml:space="preserve">
    <value>ConnectorsFR</value>
  </data>
	<data name="fieldPropertyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="arrayKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for variable "{2}" must be an integer greater than or equal to zero.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="booleanKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be a boolean.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="byteKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type byte.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="charKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type char.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateTimeKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type DateTime.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateTimeOffsetKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type DateTimeOffset.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateOnlyKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type DateOnly.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type Date.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="timeSpanKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type TimeSpan.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="timeOnlyKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type TimeOnly.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="timeOfDayKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type TimeOfDay.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="guidKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type Guid.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="decimalKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type decimal.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="doubleKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type double.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="floatKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type float.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="integerKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="longKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type long.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="sbyteKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type sbyte.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="shortKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type short.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="uIntegerKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an unsigned integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="uLongKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an unsigned long integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="uShortKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an unsigned short integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="variableKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be a configured variable.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="variableArrayKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for variable "{2}" must be a configured integer variable or positive integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="fieldPropertyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="arrayKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for function "{2}" must be an integer greater than or equal to zero.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="booleanKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be a boolean.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="byteKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type byte.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="charKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type char.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateTimeKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type DateTime.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateTimeOffsetKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type DateTimeOffset.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateOnlyKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type DateOnly.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type Date.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="timeSpanKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type TimeSpan.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="timeOnlyKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type TimeOnly.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="timeOfDayKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type TimeOfDay.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="guidKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type Guid.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="decimalKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type decimal.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="doubleKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type double.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="floatKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type float.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="integerKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="longKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type long.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="sbyteKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type sbyte.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="shortKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type short.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="uIntegerKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an unsigned integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="uLongKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an unsigned long integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="uShortKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an unsigned short integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="variableKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be a configured variable.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="variableArrayKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for function "{2}" must be a configured integer variable or positive integer.FR</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="variableNameIsInvalidFormat" xml:space="preserve">
    <value>Variable Name Field for variable "{0}" is invalid. Variable or function names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="arrayKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, each index in Member Name for variable {0}, must be an integer greater than or equal to zero.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="booleanKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be a boolean.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="byteKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type byte.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="charKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type char.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateTimeKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type DateTime.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateTimeOffsetKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type DateTimeOffset.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateOnlyKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type DateOnly.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type Date.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="timeSpanKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type TimeSpan.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="timeOnlyKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type TimeOnly.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="timeOfDayKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type TimeOfDay.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="guidKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type Guid.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="decimalKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type decimal.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="doubleKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type double.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="floatKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type float.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="integerKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an integer.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="longKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type long.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="sbyteKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type sbyte.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="shortKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type short.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="uIntegerKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an unsigned integer.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="uLongKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an unsigned long integer.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="uShortKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an unsigned short integer.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be a configured variable.FR</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableArrayIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, each index in Member Name for variable {0} must be a configured integer variable or positive integer.FR</value>
    <comment>0=variableName</comment>
  </data>
</root>