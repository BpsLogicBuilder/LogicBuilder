<?xml version="1.0" encoding="utf-8"?>
<root>
	<!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
	<xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
		<xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
		<xsd:element name="root" msdata:IsDataSet="true">
			<xsd:complexType>
				<xsd:choice maxOccurs="unbounded">
					<xsd:element name="metadata">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" />
							</xsd:sequence>
							<xsd:attribute name="name" use="required" type="xsd:string" />
							<xsd:attribute name="type" type="xsd:string" />
							<xsd:attribute name="mimetype" type="xsd:string" />
							<xsd:attribute ref="xml:space" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="assembly">
						<xsd:complexType>
							<xsd:attribute name="alias" type="xsd:string" />
							<xsd:attribute name="name" type="xsd:string" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="data">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
								<xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
							<xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
							<xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
							<xsd:attribute ref="xml:space" />
						</xsd:complexType>
					</xsd:element>
					<xsd:element name="resheader">
						<xsd:complexType>
							<xsd:sequence>
								<xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
							</xsd:sequence>
							<xsd:attribute name="name" type="xsd:string" use="required" />
						</xsd:complexType>
					</xsd:element>
				</xsd:choice>
			</xsd:complexType>
		</xsd:element>
	</xsd:schema>
	<resheader name="resmimetype">
		<value>text/microsoft-resx</value>
	</resheader>
	<resheader name="version">
		<value>2.0</value>
	</resheader>
	<resheader name="reader">
		<value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
	<resheader name="writer">
		<value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
	</resheader>
	<data name="actionIncomingConnectorCount" xml:space="preserve">
    <value>Action Shape requires at least one incoming connector.</value>
  </data>
	<data name="actionShapeOneBlankConnector" xml:space="preserve">
    <value>Action Shape requires exactly one outgoing  blank connector.</value>
  </data>
	<data name="actionShapeDataRequired" xml:space="preserve">
    <value>Action Shape requires data.</value>
  </data>
	<data name="allActionConnectorsSameStencil" xml:space="preserve">
    <value>All connectors attached to an Action Shape must belong to the same stencil. i.e. they must all be regular connectors or they must all be application specific.</value>
  </data>
	<data name="allConnectorsSameStencil" xml:space="preserve">
    <value>All connectors attached to a Module Shape must belong the same stencil. i.e. they must all be regular connectors or they must all be application specific.</value>
  </data>
	<data name="allWaitConditionsConnectorsSameStencil" xml:space="preserve">
    <value>All connectors attached to a Wait Conditions Shape must belong to the same stencil. i.e. they must all be regular connectors or they must all be application specific.</value>
  </data>
	<data name="allWaitDecisionsConnectorsSameStencil" xml:space="preserve">
    <value>All connectors attached to a Wait Decisions Shape must belong to the same stencil. i.e. they must all be regular connectors or they must all be application specific.</value>
  </data>
	<data name="applicationConnectorMismatch" xml:space="preserve">
    <value>For each incoming connector a corresponding outgoing connector is required and vice versa.</value>
  </data>
	<data name="applicationNameLogicBuilder" xml:space="preserve">
    <value>BPS Logic Builder</value>
  </data>
	<data name="applicationNameFormat" xml:space="preserve">
    <value>App{0}</value>
    <comment>0=Count</comment>
  </data>
	<data name="applicationNotConfigured" xml:space="preserve">
    <value>To use an application connector, the corresponding application must be configured. Select Project/Project Properties and the Applications tab to add applications.</value>
  </data>
	<data name="applicationUnaccountedForFormat" xml:space="preserve">
    <value>Application {0} has not been excluded for module {1} and is not accounted for. To configure excluded modules, select Project/Project Properties. In the Applications tab, select the relevant application.  Click on the button in the excluded modules text box.</value>
    <comment>0=ApplicationName 1=ModuleName</comment>
  </data>
	<data name="assemblyUnavailableMessageFormat" xml:space="preserve">
    <value>The assembly "{0}", one of its dependencies or the class "{1}" could not be loaded.</value>
    <comment>0=assemblyFullPath; 1=FullyQulifiedClassName</comment>
  </data>
	<data name="beginFlowShapeRequired" xml:space="preserve">
    <value>Document: {0} - "Begin Flow Shape" or "Module Begin Shape" is required.</value>
    <comment>0=FileName</comment>
  </data>
	<data name="beginShapeCount" xml:space="preserve">
    <value>Document: {0} - Only one Begin Shape is allowed per module.</value>
    <comment>0=FileName</comment>
  </data>
	<data name="beginShapeIncoming" xml:space="preserve">
    <value>Incoming Connectors cannot be joined to Begin Flow or Module Begin Shapes.</value>
  </data>
	<data name="beginShapeOutgoingRequired" xml:space="preserve">
    <value>Begin Flow and Module Begin Shapes require only one blank outgoing connector.</value>
  </data>
	<data name="binaryOperatorCodeNameInvalidFormat" xml:space="preserve">
    <value>Invalid Member Name "{0}" for Binary Operator "{1}". Valid code names are: {2}.</value>
    <comment>0=Member Name; 1=Function; 2=List of valid names</comment>
  </data>
	<data name="blankConnectorExitingDialogMustEndFlow" xml:space="preserve">
    <value>A blank connector leaving a Dialog Shape must point to an End Flow Shape.</value>
  </data>
	<data name="builtInFunctionNameAnd" xml:space="preserve">
    <value>And</value>
  </data>
	<data name="builtInFunctionNameChainingUpdate" xml:space="preserve">
    <value>ChainingUpdate</value>
  </data>
	<data name="builtInFunctionNameEquals" xml:space="preserve">
    <value>Equals</value>
  </data>
	<data name="builtInFunctionNameGreaterThan" xml:space="preserve">
    <value>Greater Than</value>
  </data>
	<data name="builtInFunctionNameGreaterThanOrEquals" xml:space="preserve">
    <value>Greater Than or Equals</value>
  </data>
	<data name="builtInFunctionNameLessThan" xml:space="preserve">
    <value>Less Than</value>
  </data>
	<data name="builtInFunctionNameLessThanOrEquals" xml:space="preserve">
    <value>Less Than or Equals</value>
  </data>
	<data name="builtInFunctionNameNot" xml:space="preserve">
    <value>Not</value>
  </data>
	<data name="builtInFunctionNameRemoveDecision" xml:space="preserve">
    <value>Set To Null</value>
  </data>
	<data name="builtInFunctionNameSetDecision" xml:space="preserve">
    <value>Set Variable</value>
  </data>
	<data name="builtInFunctionNameOr" xml:space="preserve">
    <value>Or</value>
  </data>
	<data name="builtInFunctionsRootFolderText" xml:space="preserve">
    <value>Built In Functions</value>
  </data>
	<data name="builtInParameterNameValue" xml:space="preserve">
    <value>value</value>
  </data>
	<data name="builtInParameterNameValue1" xml:space="preserve">
    <value>value1</value>
  </data>
	<data name="builtInParameterNameValue2" xml:space="preserve">
    <value>value2</value>
  </data>
	<data name="builtInParameterNameVariable" xml:space="preserve">
    <value>Variable</value>
  </data>
	<data name="cannotEvaluateVariableFormat" xml:space="preserve">
    <value>Type cannot be evaluated. Variable "{0}" is not configured.</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="cannotLoadAssemblyFormat" xml:space="preserve">
    <value>Assembly "{0}" could not be loaded.</value>
    <comment>0=Assembly</comment>
  </data>
	<data name="cannotLoadCastAsVariableTypeFormat" xml:space="preserve">
    <value>Cannot load "Cast Variable As" type "{0}" for the variable "{1}".</value>
    <comment>0=castAsTypeName; 1=variableName;</comment>
  </data>
	<data name="cannotLoadClassFormat" xml:space="preserve">
    <value>Class "{0}" could not be loaded.</value>
    <comment>0=ActivityClass</comment>
  </data>
	<data name="cannotLoadPropertySourceParameterFormat" xml:space="preserve">
    <value>Cannot find the required property sourced parameter "{0}" for the parameter "{1}" in constructor "{2}". The property sourced parameter must be one of the sibling parameters {3} when the control is {4}.</value>
    <comment>0=sourceParameter; 1=parameter; 2=constructor;3=SiblingParameterList; 4=ParameterSourcedProperyInputText</comment>
  </data>
	<data name="cannotLoadTypeForConstructorFormat" xml:space="preserve">
    <value>Type "{0}" could not be loaded for the constructor "{1}".</value>
    <comment>0=typeName;1=constructorName</comment>
  </data>
	<data name="cannotLoadTypeForFunctionFormat" xml:space="preserve">
    <value>The return type "{0}" could not be loaded for the function "{1}".</value>
    <comment>0=typeName;1=functionName</comment>
  </data>
	<data name="cannotLoadTypeForGenericArgumentForConstructorFormat" xml:space="preserve">
    <value>Cannot load the type for the generic argument "{0}". Constructor name: {1}.</value>
    <comment>0=generic argument name;1=constructor name</comment>
  </data>
	<data name="cannotLoadTypeForGenericArgumentForFunctionFormat" xml:space="preserve">
    <value>Cannot load the type for the generic argument "{0}". Function name: {1}.</value>
    <comment>0=generic argument name;1=function name</comment>
  </data>
	<data name="cannotLoadTypeFormat2" xml:space="preserve">
    <value>Cannot load the type "{0}".</value>
    <comment>0=typeName;</comment>
  </data>
	<data name="cannotLoadTypeForVariableFormat" xml:space="preserve">
    <value>The variable type "{0}" could not be loaded for the variable "{1}".</value>
    <comment>0=typeName;1=variableName</comment>
  </data>
	<data name="cannotSetValueTypedVariableToNullFormat" xml:space="preserve">
    <value>The variable "{0}" is a non-nullable value type and cannot be set to null.</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="castReferenceAsMustBeEmptyFormat" xml:space="preserve">
    <value>Cast Reference As field for variable {0} must be empty when the reference category is "This" or reference category is "Type".</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="chainingUpdateValidationError" xml:space="preserve">
    <value>The field or property to be updated must be represented by a string and cannot include functions or variables.</value>
  </data>
	<data name="conditionBoxIncomingRequired" xml:space="preserve">
    <value>Condition Shape requires at least one incoming connector.</value>
  </data>
	<data name="conditionBoxOutgoingRequired" xml:space="preserve">
    <value>Condition Shape requires one "YES" outgoing connector and one outgoing "NO" connector.</value>
  </data>
	<data name="conditionShapeDataRequired" xml:space="preserve">
    <value>Conditions Shape requires data.</value>
  </data>
	<data name="connectorCategoryUndefinedFormat" xml:space="preserve">
    <value>The connector category {0} is undefined.</value>
    <comment>0=connector category</comment>
  </data>
	<data name="commentShapeCannotHaveConnectors" xml:space="preserve">
    <value>Comment shapes may not be attached to connectors.</value>
  </data>
	<data name="connectorRequires2Shapes" xml:space="preserve">
    <value>Connector must be connected to 2 shapes.</value>
  </data>
	<data name="constrGenericArgNameInvalidFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for constructor "{1}" is invalid.  Generic argument names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.</value>
    <comment>0=genericArgumentName;1=parameterName;2=constructorName</comment>
  </data>
	<data name="constructorGenericArgsMisMatchFormat" xml:space="preserve">
    <value>The configured constructor's generic arguments "{0}" must match the data's generic arguments "{1}".</value>
    <comment>0=constructor's generic arguments;1= data's generic arguments</comment>
  </data>
	<data name="constructorGenericArgsMisMatchFormat2" xml:space="preserve">
    <value>The configured constructor's type name  "{0}" must be a generic type definition matching the generic arguments "{1}".</value>
    <comment>0=constructor's type name;1= data's generic arguments</comment>
  </data>
	<data name="constructorNotAssignableFormat" xml:space="preserve">
    <value>The constructor "{0}" must be assignable to "{1}".</value>
    <comment>0=constructorName;1=objectType</comment>
  </data>
	<data name="constructorNotConfiguredForObjectTypeFormat" xml:space="preserve">
    <value>There is no constructor configured for the object type "{0}".</value>
    <comment>0=typeName</comment>
  </data>
	<data name="constructorNotConfiguredForObjectTypeFormat2" xml:space="preserve">
    <value>The constructor "{0}" cannot be assigned to the object type "{1}".</value>
    <comment>0=constructorName;1=typeName</comment>
  </data>
	<data name="constructorsRootFolderText" xml:space="preserve">
    <value>Constructors</value>
  </data>
  <data name="constructorToStringFormat" xml:space="preserve">
    <value>{0} - {1}({2})</value>
    <comment>0=constructorName 1=Type 2=parametersToString</comment>
  </data>
	<data name="createNewConstructorsFileQuestion" xml:space="preserve">
    <value>Create a new Constructors File?</value>
  </data>
	<data name="createNewFragmentsFileQuestion" xml:space="preserve">
    <value>Create a new Fragments File?</value>
  </data>
	<data name="createNewFunctionsFileQuestion" xml:space="preserve">
    <value>Create a new Functions File?</value>
  </data>
	<data name="createNewProjectFileQuestion" xml:space="preserve">
    <value>Create a new Project File?</value>
  </data>
	<data name="createNewVariablesFileQuestion" xml:space="preserve">
    <value>Create a new Variables File?</value>
  </data>
	<data name="customPropertyNotFoundFormat" xml:space="preserve">
    <value>Property {0} does not exist.</value>
		<comment>0=propertyName (prefix cellname)</comment>
  </data>
	<data name="decisionBoxIncomingRequired" xml:space="preserve">
    <value>Decision Shape requires at least one incoming connector.</value>
  </data>
	<data name="decisionBoxOutgoingRequired" xml:space="preserve">
    <value>Decision Shape requires one outgoing "YES" connector and one outgoing "NO" connector.</value>
  </data>
	<data name="decisionConnectorNoText" xml:space="preserve">
    <value>NO</value>
  </data>
	<data name="decisionConnectorYesText" xml:space="preserve">
    <value>YES</value>
  </data>
	<data name="decisionShapeDataRequired" xml:space="preserve">
    <value>Decision Shape requires data.</value>
  </data>
	<data name="defaultActivityAssemblyFolder" xml:space="preserve">
    <value>ActivityAssembly</value>
  </data>
	<data name="defaultActivityClass" xml:space="preserve">
    <value>ActivityNamespace.ActivityClass</value>
  </data>
	<data name="defaultDeleteRulesUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/DeleteRules</value>
  </data>
	<data name="defaultDeleteAllRulesUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/DeleteAllRules</value>
  </data>
  <data name="defaultErrorMessage" xml:space="preserve">
    <value>An error has occurred</value>
  </data>
	<data name="defaultPostFileDataUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/PostFileData</value>
  </data>
	<data name="defaultPostVariableMetaDataUrl" xml:space="preserve">
    <value>http://localhost:3677/api/transfer/PostVariableMetaData</value>
  </data>
	<data name="defaultResourcesFile" xml:space="preserve">
    <value>strings.resources</value>
  </data>
	<data name="defaultResourcesFolder" xml:space="preserve">
    <value>Resources</value>
  </data>
	<data name="defaultRulesFile" xml:space="preserve">
    <value>expert.rules</value>
  </data>
	<data name="defaultRulesFolder" xml:space="preserve">
    <value>Rules</value>
  </data>
	<data name="diagramVisibleLinkFormat" xml:space="preserve">
    <value>Document: {0}, Page: {1}, Master: {2}, Shape Index: {3}.</value>
    <comment>0=fileName; 1=PageNumber; 2=Master; 3=ShapeIndex</comment>
  </data>
	<data name="dialogDuplicateChoiceFormat" xml:space="preserve">
    <value>Shape has two connectors with identical choices.  Connector number {0} is a duplicate.</value>
    <comment>0=Duplicate Connector Number</comment>
  </data>
	<data name="dialogFunctionsInvalid" xml:space="preserve">
    <value>Dialog Functions are invalid for Action Shape.</value>
  </data>
	<data name="dialogFunctionsInvalidConnector" xml:space="preserve">
    <value>Dialog Functions are invalid for Connectors.</value>
  </data>
	<data name="dialogInvalidConnectorsFormat" xml:space="preserve">
    <value>Shape with multiple connectors has {0} invalid connector(s).</value>
    <comment>0=#OfInvalidConnectors</comment>
  </data>
	<data name="dialogOrQuestionsOutgoingCount" xml:space="preserve">
    <value>Either one connector which is blank, one connector which is not blank or multiple connectors all of which are not blank can exit a Dialog shape.</value>
  </data>
	<data name="dialogShapeDataRequired" xml:space="preserve">
    <value>Dialog Shape Requires data.</value>
  </data>
	<data name="dialogShapeOnlyOneFunction" xml:space="preserve">
    <value>Only one function allowed per Dialog Shape.</value>
  </data>
	<data name="dialogShapeRequiresIncomming" xml:space="preserve">
    <value>Dialog Shape requires at least one incoming connector.</value>
  </data>
	<data name="dialogShapesOneDialogFunction" xml:space="preserve">
    <value>Dialog Shape requires exactly one dialog function.</value>
  </data>
	<data name="dotExe" xml:space="preserve">
    <value>.exe</value>
  </data>
	<data name="duplicateIncomingConnector" xml:space="preserve">
    <value>Only one incoming connector per application is valid.</value>
  </data>
	<data name="duplicateOutgoingConnector" xml:space="preserve">
    <value>Only one outgoing connector per application is valid.</value>
  </data>
	<data name="endShapeIncoming" xml:space="preserve">
    <value>End Flow, Module End and Terminate Shapes require at least one incoming connector.</value>
  </data>
	<data name="endShapeOutgoing" xml:space="preserve">
    <value>Outgoing Connectors cannot be joined to End Flow, Module End or Terminate Shapes.</value>
  </data>
	<data name="fragmentsRootNodeText" xml:space="preserve">
    <value>Fragments</value>
  </data>
	<data name="funcCannotLoadPropertySourceParameterFormat" xml:space="preserve">
    <value>Cannot find the required property sourced parameter "{0}" for the parameter "{1}" in function "{2}". The property sourced parameter must be one of the sibling parameters {3} when the control is {4}.</value>
    <comment>0=sourceParameter; 1=parameter; 2=function;3=SiblingParameterList; 4=ParameterSourcedProperyInputText</comment>
  </data>
	<data name="funcGenericArgNameInvalidFormat" xml:space="preserve">
    <value>The generic argument name "{0}" in function "{1}" is invalid.  Generic argument names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.</value>
    <comment>0=genericArgumentName;1=parameterName;2=functionName</comment>
  </data>
	<data name="funcGenericArgNotValidForAllReferenceCatFormat" xml:space="preserve">
    <value>Generic arguments are only valid when the reference category is "Type". Function name: "{0}".</value>
    <comment>0=functionName</comment>
  </data>
	<data name="funcGenericParameterArgNameNotFoundFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for generic parameter "{1}" in function "{2}" is not one of the function's generic arguments: "{3}".</value>
    <comment>0=genericArgumentName;1=parameterName;2=functionName;3=listOfGenericArguments</comment>
  </data>
	<data name="funcGenericReturnTypeArgNameNotFoundFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for the return type in function "{1}" is not one of the function's generic arguments: "{2}".</value>
    <comment>0=genericArgumentName;1=functionName;2=listOfGenericArguments</comment>
  </data>
	<data name="functionBlankCategoryFormat" xml:space="preserve">
    <value>Reference Category for function "{0}" cannot be empty.</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionGenericArgsMisMatchFormat" xml:space="preserve">
    <value>The configured function's generic arguments "{0}" must match the data's generic arguments "{1}".</value>
    <comment>0=function's generic arguments;1= data's generic arguments</comment>
  </data>
	<data name="functionGenericArgsMisMatchFormat2" xml:space="preserve">
    <value>The configured function's reference category must be "{0}", and the type name "{1}" must be a generic type definition matching the generic arguments "{2}".</value>
    <comment>0reference category;1=function's type name;1= data's generic arguments</comment>
  </data>
	<data name="functionInvalidCategoryFormat" xml:space="preserve">
    <value>Function "{0}" has invalid Reference Category "{1}". Valid categories are:{2}{3}</value>
    <comment>0=functionName; 1=Referencecategory; 2=Environment.Newline; 3=ValidCategories</comment>
  </data>
	<data name="functionInvalidIndirectDefinitionFormat" xml:space="preserve">
    <value>Function "{0}" has invalid section "{1}" in its Reference Definition Field. Valid sections for indirect references include:{2}{3}</value>
    <comment>0=functionName; 1=ReferenceDefinition; 2=Environment.Newline; 3=ValidDefinitionList</comment>
  </data>
	<data name="functionNameAndCastAsFormat" xml:space="preserve">
    <value>Function "{0}". When it is not empty, Cast Reference As and Reference Name must have an equal number of sections when the function is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.0.boz, Cast Reference As = ~.~.~."MyNameSpace.MyClass" (Use a tilde (~) where a cast is not needed. Use quotes as a text qualifier when the fully qualified class name contains a period).</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionNameAndDefinitionFormat" xml:space="preserve">
    <value>Function "{0}". Reference Name and Reference Definition must have an equal number of sections when the function is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.0.boz, Reference Definition = Field.Property.IntKeyValue.Field.</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionNotAssignableFormat" xml:space="preserve">
    <value>The function "{0}" must be assignable to "{1}".</value>
    <comment>0=functionName;1=objectType</comment>
  </data>
	<data name="functionNotConfiguredFormat" xml:space="preserve">
    <value>Function "{0}" is not configured.</value>
    <comment>0=FunctionName</comment>
  </data>
	<data name="functionReferenceInfoMustBePopulatedFormat" xml:space="preserve">
    <value>Reference Name and Reference Definition field for function {0} must be populated when the reference category is "Instance Reference" or reference category is "Static Reference".</value>
    <comment>0=functionName</comment>
  </data>
	<data name="functionReferenceMustBeEmptyFormat" xml:space="preserve">
    <value>Reference Name field for function {0} must be empty when the reference category is "This", "Type" or "None".</value>
  </data>
	<data name="functionsRootFolderText" xml:space="preserve">
    <value>Functions</value>
  </data>
	<data name="functionToStringFormat" xml:space="preserve">
    <value>{0} - {1}({2})</value>
    <comment>0=functionName 1=Type 2=parametersToString</comment>
  </data>
	<data name="functionTypeNameMustBeEmptyFormat" xml:space="preserve">
    <value>Type Name field for function {0} must be empty when the reference category is not "Type"or "Static Reference".</value>
    <comment>0=functionName</comment>
  </data>
	<data name="genericMethodsNotSupportedFormat" xml:space="preserve">
    <value>Generic methods are not supported. Method name: "{0}".</value>
    <comment>0=methodName</comment>
  </data>
	<data name="genericParameterArgNameNotFoundFormat" xml:space="preserve">
    <value>The generic argument name "{0}" for generic parameter "{1}" in constructor "{2}" is not one of the constructor's generic arguments: "{3}".</value>
    <comment>0=genericArgumentName;1=parameterName;2=constructorName;3=listOfGenericArguments</comment>
  </data>
	<data name="invalidAnyParameterConfigurationForBinaryOperatorFormat" xml:space="preserve">
		<value>For the binary operator "{0}", both parameters can be of literal type "Any" or neither can be of literal type "Any". First parameter: "{1}", second parameter: "{2}".</value>
	</data>
	<data name="invalidArgumentTextFormat" xml:space="preserve">
    <value>Invalid Argument {0}.</value>
  </data>
	<data name="invalidConfigurationDocumentFormat" xml:space="preserve">
    <value>{0} has invalid data.</value>
    <comment>{0}=fileFullName</comment>
  </data>
	<data name="invalidConsParameterOrder" xml:space="preserve">
    <value>The parameter order for constructor "{0}" is invalid. Move optional parameters to the end of the parameters list.</value>
    <comment>0=FunctionName</comment>
  </data>
	<data name="invalidFunctionCategoryFormat" xml:space="preserve">
    <value>Function "{0}" has invalid function category "{1}" given the element type "{2}".</value>
    <comment>0=functionName;1=functionCategory;2=elementName</comment>
  </data>
	<data name="invalidLiteralInputFormat" xml:space="preserve">
    <value>Input "{0}" is invalid for the literal type "{1}".</value>
    <comment>0=input, 1=Type</comment>
  </data>
	<data name="invalidLiteralInputFormat2" xml:space="preserve">
    <value>Input is invalid for the literal type "{0}".</value>
    <comment>0=Type</comment>
  </data>
	<data name="invalidMaster" xml:space="preserve">
    <value>Shape must belong to the Logic Builder or Applications Stencil.</value>
  </data>
	<data name="invalidModuleName" xml:space="preserve">
    <value>Module name {0} is invalid.</value>
    <comment>0=ModuleName</comment>
  </data>
	<data name="invalidParameterElementFormat" xml:space="preserve">
    <value>The parameter "{0}" has an invalid element for the category "{1}".</value>
    <comment>0=parameterName;1=parameterCategory;</comment>
  </data>
	<data name="invalidParameterOrder" xml:space="preserve">
    <value>The parameter order for function "{0}" is invalid. Move optional parameters to the end of the parameters list.</value>
    <comment>0=FunctionName</comment>
  </data>
	<data name="invalidVariableElementFormat" xml:space="preserve">
    <value>The variable "{0}" has an invalid value element for the category "{1}".</value>
    <comment>0=parameterName;1=parameterCategory;</comment>
  </data>
	<data name="itemsCommaSeparator" xml:space="preserve">
    <value>, </value>
  </data>
	<data name="jumpConnectorsBothDirections" xml:space="preserve">
    <value>For a Jump Shape, the connectors must be all incoming or all outgoing.</value>
  </data>
	<data name="jumpShape1OutGoing" xml:space="preserve">
    <value>Only one outgoing connector allowed per Jump Shape.</value>
  </data>
	<data name="jumpShapeDataRequired" xml:space="preserve">
    <value>Jump Shape requires data.</value>
  </data>
	<data name="jumpShapeNoMatchingFromShape" xml:space="preserve">
    <value>"To" Jump Shape has no matching "From" Jump Shape.</value>
  </data>
	<data name="jumpShapeNoMatchingToShape" xml:space="preserve">
    <value>"From" Jump Shape has no matching "To" Jump Shape.</value>
  </data>
	<data name="jumpShapeUniqueTextForToShape" xml:space="preserve">
    <value>Duplicate Jump Shape. Text in a "To" Jump Shapes must be unique.</value>
  </data>
	<data name="listParameterTypeNameFormat" xml:space="preserve">
    <value>{0}Of{1}: {2}</value>
    <comment>0=listType 1=UnderlyingType 2=name</comment>
  </data>
	<data name="listDescriptionFormat" xml:space="preserve">
    <value>{0} Of {1}</value>
    <comment>0=listType 1=UnderlyingType</comment>
  </data>
	<data name="listVariableTypeFormat" xml:space="preserve">
    <value>{0}Of{1}</value>
    <comment>0=listType 1=UnderlyingType</comment>
  </data>
	<data name="memberNameIsInvalidFormat" xml:space="preserve">
    <value>Member Name Field for function {0} is invalid. Variable or function names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.</value>
    <comment>0=functionName</comment>
  </data>
	<data name="mergeAppConnectorComments" xml:space="preserve">
    <value>Merge Object requires a minimum of two attached application connectors all pointing in the same direction (all incoming or all outgoing).</value>
  </data>
	<data name="mergeBranchingComments" xml:space="preserve">
    <value>When branching the process, Merge Object requires at least one incoming non-application connector.</value>
  </data>
	<data name="mergeHasAppAndNonAppInConnectors" xml:space="preserve">
    <value>Merge Object may not be attached to both application and regular incoming connectors.</value>
  </data>
	<data name="mergeHasAppAndNonAppOutConnectors" xml:space="preserve">
    <value>Merge Object may not be attached to both application and regular outgoing connectors.</value>
  </data>
	<data name="mergeHasInAndOutAppConnectors" xml:space="preserve">
    <value>Merge Object may not be attached to both outgoing and incoming application connectors.</value>
  </data>
	<data name="mergeHasInAndOutNonAppConnectors" xml:space="preserve">
    <value>Merge Object may not be attached to both outgoing and incoming non-application connectors.</value>
  </data>
	<data name="mergeMergingComments" xml:space="preserve">
    <value>When merging processes, Merge Object requires exactly one outgoing non-application connector.</value>
  </data>
	<data name="metaObjectRequiredForDialogConnectorsFormat" xml:space="preserve">
    <value>The {0} element is required for dialog connectors.</value>
    <comment>0=connector category</comment>
  </data>
	<data name="moduleEndIsInvalidForBeginFlow" xml:space="preserve">
    <value>Module End shape is invalid when the initial shape is Begin Flow.</value>
  </data>
	<data name="moduleIsExcludedFormat" xml:space="preserve">
    <value>Module {0} is excluded for application {1}. To configure excluded modules, select Project/Project Properties. In the Applications tab, select the relevant application.  Click on the button in the excluded modules text box.</value>
    <comment>0=ModuleName; 1=ApplicationName</comment>
  </data>
	<data name="moduleShapeDataRequired" xml:space="preserve">
    <value>Module Shape requires data.</value>
  </data>
	<data name="moduleShapeIncoming" xml:space="preserve">
    <value>Module Shape requires at least one incoming connector.</value>
  </data>
	<data name="moduleShapeOutgoing" xml:space="preserve">
    <value>Module Shape requires a single blank outgoing connector.</value>
  </data>
	<data name="multipleChoiceParamNotLastFormat" xml:space="preserve">
    <value>Error configuring method {0}. The connectors multiple choice parameter must be the last parameter.</value>
    <comment>0=functionName</comment>
  </data>
	<data name="neitherOperandCanBeEmptyBinaryOperationAny" xml:space="preserve">
    <value>Neither operand can be empty if 1) the function is a binary operation, 2) parameter type for the operands is Any, and 3) the other operand is not nullable.</value>
  </data>
	<data name="noConnectorsOnJumpFormat" xml:space="preserve">
    <value>Jump shape has no connectors.</value>
  </data>
	<data name="notImplementedMessageFormat" xml:space="preserve">
    <value>Method not implemented in {0}.</value>
  </data>
	<data name="othersConnectorInvalid" xml:space="preserve">
    <value>Others Connect Object is invalid when all applications are accounted for.</value>
  </data>
	<data name="parameterCountMustBeTwoFormat" xml:space="preserve">
    <value>Because Parameters Layout is Binary, function {0} must have exactly 2 parameters.</value>
  </data>
	<data name="parameterNotLiteralFormat" xml:space="preserve">
    <value>The parameter "{0}" of type "{1}" is not a valid literal.</value>
  </data>
	<data name="parameterNotOptionalFormat" xml:space="preserve">
    <value>Parameter "{0}" is not optional.</value>
  </data>
	<data name="parametersLayoutMustBeBinaryFormat" xml:space="preserve">
    <value>Parameters Layout for function {0} must be "Binary" when the function category is "Binary Operator".</value>
    <comment>0=functionName</comment>
  </data>
	<data name="parametersNotCompatibleForBinaryOperation" xml:space="preserve">
    <value>The parameter types "{0}" and "{1}" cannot be applied as operands in the binary operation "{2}".</value>
  </data>
	<data name="parameterTypeNameFormat2" xml:space="preserve">
    <value>{0}: {1}</value>
    <comment>0=type 1=name</comment>
  </data>
	<data name="progressFormTaskInitializingPageFormat" xml:space="preserve">
    <value>Initializing Page {0}</value>
    <comment>0=PageIndex</comment>
  </data>
	<data name="referenceCannotEqualVariable" xml:space="preserve">
    <value>The variable index cannot be the same as the variable it references. Reference Name: "{0}", variable: "{1}".</value>
    <comment>0=referenceName; 1=variableName</comment>
  </data>
	<data name="referenceCategoryCannotBeNoneFormat" xml:space="preserve">
    <value>Reference Category for function {0} cannot be "None" given the function category.</value>
  </data>
	<data name="referenceCategoryMustBeNoneFormat" xml:space="preserve">
    <value>Reference Category for function {0} must be "None" when the function category is "Binary Operator".</value>
  </data>
	<data name="referenceNameAndCastReferenceAFormat" xml:space="preserve">
    <value>Variable "{0}". When it is not empty, Cast Reference As and Reference Name must have an equal number of sections when the variable is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.1.boz, Cast Reference As = ~.~.~."MyNameSpace.MyClass" (Use a tilde (~) where a cast is not needed. Use quotes as a text qualifier when the fully qualified class name contains a period).</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="shapeConnectedToBothEnds" xml:space="preserve">
    <value>The same Action Shape or Jump Object may not be connected to both ends of a connector.</value>
  </data>
	<data name="spaceString" xml:space="preserve">
    <value>&#32;</value>
  </data>
	<data name="tableVisibleLinkFormat" xml:space="preserve">
    <value>Document: {0}, Row: {1}, Column: {2}.</value>
    <comment>0=FileName; 1=row; 2=column</comment>
  </data>
	<data name="truncatedMessageTextFormat" xml:space="preserve">
    <value>{0} ...</value>
    <comment>0=truncated message</comment>
  </data>
	<data name="twoApplicationsMinimum" xml:space="preserve">
    <value>To use application connectors a minimum of two applications must be configured. Select Project/Project Properties and the Applications tab to add applications.</value>
  </data>
	<data name="typeNotAssignableFormat" xml:space="preserve">
    <value>The type "{0}" is not assignable to "{1}".</value>
    <comment>0=typeWeAreValidating;1=assignedToType</comment>
  </data>
	<data name="typeReferenceNameIsInvalidFormat" xml:space="preserve">
    <value>Fully Qualified Type Reference Name field for function {0} is invalid. Fully Qualified Class Names must start with an alpha character or underscore and can contain only alphanumeric characters, periods, plus (+) characters and underscores.</value>
    <comment>0=functionName</comment>
  </data>
	<data name="typeReferenceNameIsInvalidConstructorFormat" xml:space="preserve">
    <value>Fully Qualified Type Reference Name field for constructor {0} is invalid. Fully Qualified Class Names must start with an alpha character or underscore and can contain only alphanumeric characters, periods, plus (+) characters and underscores.</value>
    <comment>0=functionName</comment>
  </data>
	<data name="typeReferenceNameIsInvalidFormatVariable" xml:space="preserve">
    <value>Fully Qualified Type Name field for variable {0} is invalid. Fully Qualified Class Names must start with an alpha character or underscore and can contain only alphanumeric characters, periods, plus (+) characters and underscores.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="underscore" xml:space="preserve">
    <value>_</value>
  </data>
	<data name="unhandledEventLoggerExceptionFormat" xml:space="preserve">
    <value>The event logger has generated an unhandled exception of type: "{0}". Message: "{1}".</value>
  </data>
	<data name="validApplicationSpecificShapes" xml:space="preserve">
    <value>Shapes that can be connected to an Application Specific Connector are as follows: "Action", "Merge", "Module", "Wait Condition", "Wait Decision".</value>
  </data>
	<data name="variableBlankCategoryFormat" xml:space="preserve">
    <value>Reference Category for variable "{0}" cannot be empty.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableIndexCannotBeSelfFormat" xml:space="preserve">
    <value>The variable index in the Variable Name field, cannot be used to reference itself. Variable: "{0}".</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableInvalidCategoryFormat" xml:space="preserve">
    <value>Variable "{0}" has invalid Reference Category "{1}". Valid categories are:{2}{3}.</value>
    <comment>0=variableName; 1=Referencecategory; 2=Environment.Newline; 3=ValidCategoryList</comment>
  </data>
	<data name="variableInvalidIndirectDefinitionFormat" xml:space="preserve">
    <value>Variable "{0}" has invalid section "{1}" in its Reference Definition Field. Valid sections for indirect references include:{2}{3}.</value>
    <comment>0=variableName; 1=ReferenceDefinition; 2=Environment.Newline; 3=ValidDefinitionList</comment>
  </data>
	<data name="variableNameAndDefinitionFormat" xml:space="preserve">
    <value>Variable "{0}". Reference Name and Reference Definition must have an equal number of sections when the variable is indirectly referenced by the Activity Class. e.g. Reference Name = foo.Bar.1.boz, Reference Category = Field.Property.IntKeyValue.Field.</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variableNotAssignableFormat" xml:space="preserve">
    <value>The variable "{0}" must be assignable to "{1}".</value>
    <comment>0=variableName;1=objectType</comment>
  </data>
	<data name="variableReferenceDefinitionMustBeEmptyFormat" xml:space="preserve">
    <value>Reference Definition field for variable {0} must be empty when the reference category is "This" or reference category is "Type" or the evaluation is "Automatic".</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variableReferenceInfoMustBePopulatedFormat" xml:space="preserve">
    <value>Reference Name and Reference Definition field for variable {0} must be populated when the reference category is "Instance Reference" or reference category is "Static Reference".</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variableReferenceMustBeEmptyFormat" xml:space="preserve">
    <value>Reference Name field for variable {0} must be empty when the reference category is "This" or reference category is "Type" or the evaluation is "Automatic".</value>
    <comment>0=VariableName</comment>
  </data>
	<data name="variablesRootNodeText" xml:space="preserve">
    <value>Variables</value>
  </data>
	<data name="variableTypeNameMustBeEmptyFormat" xml:space="preserve">
    <value>Type Name field for  variable {0} must be empty when the reference category is not "Type"or "Static Reference".</value>
  </data>
	<data name="waitConditionShapeDataRequired" xml:space="preserve">
    <value>Wait Condition Shape requires data.</value>
  </data>
	<data name="waitConditionShapeIncomingRequired" xml:space="preserve">
    <value>Wait Condition Shape requires at least one incoming connector.</value>
  </data>
	<data name="waitConditionShapeOutgoingRequired" xml:space="preserve">
    <value>Wait Condition Shape requires exactly one outgoing  blank connector.</value>
  </data>
	<data name="waitDecisionShapeDataRequired" xml:space="preserve">
    <value>Wait Decision Shape requires data.</value>
  </data>
	<data name="waitDecisionShapeIncomingRequired" xml:space="preserve">
    <value>Wait Decision Shape requires at least one incoming connector.</value>
  </data>
	<data name="waitDecisionShapeOutgoingRequired" xml:space="preserve">
    <value>Wait Decision Shape requires exactly one outgoing  blank connector.</value>
  </data>
	<data name="enumDescriptionAny" xml:space="preserve">
    <value>Any</value>
  </data>
	<data name="enumDescriptionBoolean" xml:space="preserve">
    <value>Boolean</value>
  </data>
	<data name="enumDescriptionDateTime" xml:space="preserve">
    <value>DateTime</value>
  </data>
	<data name="enumDescriptionDateTimeOffset" xml:space="preserve">
    <value>DateTimeOffset</value>
  </data>
	<data name="enumDescriptionDateOnly" xml:space="preserve">
    <value>DateOnly</value>
  </data>
	<data name="enumDescriptionDate" xml:space="preserve">
    <value>DateTime</value>
  </data>
	<data name="enumDescriptionTimeSpan" xml:space="preserve">
    <value>TimeSpan</value>
  </data>
	<data name="enumDescriptionTimeOnly" xml:space="preserve">
    <value>TimeOnly</value>
  </data>
	<data name="enumDescriptionTimeOfDay" xml:space="preserve">
    <value>TimeOfDay</value>
  </data>
	<data name="enumDescriptionLong" xml:space="preserve">
    <value>Long</value>
  </data>
	<data name="enumDescriptionByte" xml:space="preserve">
    <value>Byte</value>
  </data>
	<data name="enumDescriptionChar" xml:space="preserve">
    <value>Char</value>
  </data>
	<data name="enumDescriptionDouble" xml:space="preserve">
    <value>Double</value>
  </data>
	<data name="enumDescriptionFloat" xml:space="preserve">
    <value>Float</value>
  </data>
	<data name="enumDescriptionShort" xml:space="preserve">
    <value>Short</value>
  </data>
	<data name="enumDescriptionSByte" xml:space="preserve">
    <value>Signed Byte</value>
  </data>
	<data name="enumDescriptionString" xml:space="preserve">
    <value>String</value>
  </data>
	<data name="enumDescriptionUInteger" xml:space="preserve">
    <value>Unsigned Integer</value>
  </data>
	<data name="enumDescriptionULong" xml:space="preserve">
    <value>Unsigned Long</value>
  </data>
	<data name="enumDescriptionUShort" xml:space="preserve">
    <value>Unsigned Short</value>
  </data>
	<data name="enumDescriptionGuid" xml:space="preserve">
    <value>Guid</value>
  </data>
	<data name="enumDescriptionDecimal" xml:space="preserve">
    <value>Decimal</value>
  </data>
	<data name="enumDescriptionInteger" xml:space="preserve">
    <value>Integer</value>
  </data>
	<data name="enumDescriptionNullableDecimal" xml:space="preserve">
    <value>Nullable Decimal</value>
  </data>
	<data name="enumDescriptionNullableInteger" xml:space="preserve">
    <value>Nullable Integer</value>
  </data>
	<data name="enumDescriptionNullableBoolean" xml:space="preserve">
    <value>Nullable Boolean</value>
  </data>
	<data name="enumDescriptionNullableDateTime" xml:space="preserve">
    <value>Nullable DateTime</value>
  </data>
	<data name="enumDescriptionNullableDateTimeOffset" xml:space="preserve">
    <value>Nullable DateTimeOffset</value>
  </data>
	<data name="enumDescriptionNullableDateOnly" xml:space="preserve">
    <value>Nullable DateOnly</value>
  </data>
	<data name="enumDescriptionNullableDate" xml:space="preserve">
    <value>Nullable Date</value>
  </data>
	<data name="enumDescriptionNullableTimeSpan" xml:space="preserve">
    <value>Nullable TimeSpan</value>
  </data>
	<data name="enumDescriptionNullableTimeOnly" xml:space="preserve">
    <value>Nullable TimeOnly</value>
  </data>
	<data name="enumDescriptionNullableTimeOfDay" xml:space="preserve">
    <value>Nullable TimeOfDay</value>
  </data>
	<data name="enumDescriptionNullableGuid" xml:space="preserve">
    <value>Nullable Guid</value>
  </data>
	<data name="enumDescriptionNullableByte" xml:space="preserve">
    <value>Nullable Byte</value>
  </data>
	<data name="enumDescriptionNullableShort" xml:space="preserve">
    <value>Nullable Short</value>
  </data>
	<data name="enumDescriptionNullableLong" xml:space="preserve">
    <value>Nullable Long</value>
  </data>
	<data name="enumDescriptionNullableFloat" xml:space="preserve">
    <value>Nullable Float</value>
  </data>
	<data name="enumDescriptionNullableDouble" xml:space="preserve">
    <value>Nullable Double</value>
  </data>
	<data name="enumDescriptionNullableChar" xml:space="preserve">
    <value>Nullable Char</value>
  </data>
	<data name="enumDescriptionNullableSByte" xml:space="preserve">
    <value>Nullable SByte</value>
  </data>
	<data name="enumDescriptionNullableUShort" xml:space="preserve">
    <value>Nullable UShort</value>
  </data>
	<data name="enumDescriptionNullableUInteger" xml:space="preserve">
    <value>Nullable UInteger</value>
  </data>
	<data name="enumDescriptionNullableULong" xml:space="preserve">
    <value>Nullable ULong</value>
  </data>
	<data name="enumDescriptionVoid" xml:space="preserve">
    <value>Void</value>
  </data>
	<data name="enumDescriptionArray" xml:space="preserve">
    <value>Array</value>
  </data>
	<data name="enumDescriptionGenericList" xml:space="preserve">
    <value>Generic List</value>
  </data>
	<data name="enumDescriptionGenericCollection" xml:space="preserve">
    <value>Generic Collection</value>
  </data>
	<data name="enumDescriptionIGenericList" xml:space="preserve">
    <value>Generic List Interface</value>
  </data>
	<data name="enumDescriptionIGenericCollection" xml:space="preserve">
    <value>Generic Collection Interface</value>
  </data>
	<data name="enumDescriptionIGenericEnumerable" xml:space="preserve">
    <value>Generic Enumerable Interface</value>
  </data>
	<data name="enumDescriptionField" xml:space="preserve">
    <value>Field</value>
  </data>
	<data name="enumDescriptionProperty" xml:space="preserve">
    <value>Property</value>
  </data>
	<data name="enumDescriptionInstanceReference" xml:space="preserve">
    <value>Instance Reference</value>
  </data>
	<data name="enumDescriptionStaticReference" xml:space="preserve">
    <value>Static Reference</value>
  </data>
	<data name="enumDescriptionNone" xml:space="preserve">
    <value>None</value>
  </data>
	<data name="enumDescriptionThis" xml:space="preserve">
    <value>This</value>
  </data>
	<data name="enumDescriptionType" xml:space="preserve">
    <value>Type</value>
  </data>
	<data name="enumDescriptionArrayIndexer" xml:space="preserve">
    <value>ArrayItem</value>
  </data>
	<data name="enumDescriptionIntegerKeyIndexer" xml:space="preserve">
    <value>IntKeyValue</value>
  </data>
	<data name="enumDescriptionStringKeyIndexer" xml:space="preserve">
    <value>StringKeyValue</value>
  </data>
	<data name="enumDescriptionBooleanKeyIndexer" xml:space="preserve">
    <value>BoolKeyValue</value>
  </data>
	<data name="enumDescriptionByteKeyIndexer" xml:space="preserve">
    <value>ByteKeyValue</value>
  </data>
	<data name="enumDescriptionCharKeyIndexer" xml:space="preserve">
    <value>CharKeyValue</value>
  </data>
	<data name="enumDescriptionDateTimeKeyIndexer" xml:space="preserve">
    <value>DateTimeKeyValue</value>
  </data>
	<data name="enumDescriptionDateTimeOffsetKeyIndexer" xml:space="preserve">
    <value>DateTimeOffsetKeyValue</value>
  </data>
	<data name="enumDescriptionDateOnlyKeyIndexer" xml:space="preserve">
    <value>DateOnlyKeyValue</value>
  </data>
	<data name="enumDescriptionDateKeyIndexer" xml:space="preserve">
    <value>DateKeyValue</value>
  </data>
	<data name="enumDescriptionTimeSpanKeyIndexer" xml:space="preserve">
    <value>TimeSpanKeyValue</value>
  </data>
	<data name="enumDescriptionTimeOnlyKeyIndexer" xml:space="preserve">
    <value>TimeOnlyKeyValue</value>
  </data>
	<data name="enumDescriptionTimeOfDayKeyIndexer" xml:space="preserve">
    <value>TimeOfDayKeyValue</value>
  </data>
	<data name="enumDescriptionGuidKeyIndexer" xml:space="preserve">
    <value>GuidKeyValue</value>
  </data>
	<data name="enumDescriptionDecimalKeyIndexer" xml:space="preserve">
    <value>DecimalKeyValue</value>
  </data>
	<data name="enumDescriptionDoubleKeyIndexer" xml:space="preserve">
    <value>DoubleKeyValue</value>
  </data>
	<data name="enumDescriptionFloatKeyIndexer" xml:space="preserve">
    <value>FloatKeyValue</value>
  </data>
	<data name="enumDescriptionLongKeyIndexer" xml:space="preserve">
    <value>LongKeyValue</value>
  </data>
	<data name="enumDescriptionSByteKeyIndexer" xml:space="preserve">
    <value>SByteKeyValue</value>
  </data>
	<data name="enumDescriptionShortKeyIndexer" xml:space="preserve">
    <value>ShortKeyValue</value>
  </data>
	<data name="enumDescriptionUIntegerKeyIndexer" xml:space="preserve">
    <value>UIntKeyValue</value>
  </data>
	<data name="enumDescriptionULongKeyIndexer" xml:space="preserve">
    <value>ULongKeyValue</value>
  </data>
	<data name="enumDescriptionUShortKeyIndexer" xml:space="preserve">
    <value>UShortKeyValue</value>
  </data>
	<data name="enumDescriptionVariableKeyIndexer" xml:space="preserve">
    <value>VariableKeyValue</value>
  </data>
	<data name="enumDescriptionVariableArrayIndexer" xml:space="preserve">
    <value>VariableKeyArrayItem</value>
  </data>
	<data name="enumDescriptionDropDown" xml:space="preserve">
    <value>DropDown</value>
  </data>
	<data name="enumDescriptionMultipleLineTextBox" xml:space="preserve">
    <value>Multiple Line Text box</value>
  </data>
	<data name="enumDescriptionSingleLineTextBox" xml:space="preserve">
    <value>Single Line Text box</value>
  </data>
	<data name="enumDescriptionTypeAutoComplete" xml:space="preserve">
    <value>Type Auto Complete</value>
  </data>
	<data name="enumDescriptionDomainAutoComplete" xml:space="preserve">
    <value>Domain Auto Complete</value>
  </data>
	<data name="enumDescriptionPropertyInput" xml:space="preserve">
    <value>Property Input</value>
  </data>
	<data name="enumDescriptionParameterSourcedPropertyInput" xml:space="preserve">
    <value>Parameter Sourced Property Input</value>
  </data>
	<data name="enumDescriptionParameterSourceOnly" xml:space="preserve">
    <value>Parameter Source Only</value>
  </data>
	<data name="enumDescriptionLiteral" xml:space="preserve">
    <value>Literal</value>
  </data>
	<data name="enumDescriptionObject" xml:space="preserve">
    <value>Object</value>
  </data>
	<data name="enumDescriptionGeneric" xml:space="preserve">
    <value>Generic</value>
  </data>
	<data name="enumDescriptionLiteralList" xml:space="preserve">
    <value>Literal List</value>
  </data>
	<data name="enumDescriptionObjectList" xml:space="preserve">
    <value>Object List</value>
  </data>
	<data name="enumDescriptionListForm" xml:space="preserve">
    <value>List Form</value>
  </data>
	<data name="enumDescriptionHashSetForm" xml:space="preserve">
    <value>Hash Set Form</value>
  </data>
	<data name="enumDescriptionConnectors" xml:space="preserve">
    <value>Connectors</value>
  </data>
	<data name="fieldPropertyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="arrayKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for variable "{2}" must be an integer greater than or equal to zero.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="booleanKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be a boolean.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="byteKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type byte.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="charKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type char.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateTimeKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type DateTime.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateTimeOffsetKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type DateTimeOffset.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateOnlyKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type DateOnly.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="dateKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type Date.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="timeSpanKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type TimeSpan.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="timeOnlyKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type TimeOnly.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="timeOfDayKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type TimeOfDay.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="guidKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type Guid.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="decimalKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type decimal.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="doubleKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type double.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="floatKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type float.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="integerKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="longKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type long.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="sbyteKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type sbyte.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="shortKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be of type short.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="uIntegerKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an unsigned integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="uLongKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an unsigned long integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="uShortKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be an unsigned short integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="variableKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for variable "{2}" must be a configured variable.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="variableArrayKeyReferenceIsInvalidFormat2" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for variable "{2}" must be a configured integer variable or positive integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=variableName</comment>
  </data>
	<data name="fieldPropertyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="arrayKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for function "{2}" must be an integer greater than or equal to zero.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="booleanKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be a boolean.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="byteKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type byte.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="charKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type char.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateTimeKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type DateTime.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateTimeOffsetKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type DateTimeOffset.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateOnlyKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type DateOnly.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="dateKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type Date.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="timeSpanKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type TimeSpan.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="timeOnlyKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type TimeOnly.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="timeOfDayKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type TimeOfDay.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="guidKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type Guid.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="decimalKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type decimal.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="doubleKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type double.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="floatKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type float.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="integerKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="longKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type long.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="sbyteKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type sbyte.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="shortKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be of type short.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="uIntegerKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an unsigned integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="uLongKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an unsigned long integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="uShortKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be an unsigned short integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="variableKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", Reference Name "{1}" for function "{2}" must be a configured variable.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="variableArrayKeyReferenceIsInvalidFormat3" xml:space="preserve">
    <value>Given the reference definition "{0}", each index in Reference Name "{1}" for function "{2}" must be a configured integer variable or positive integer.</value>
    <comment>0=referenceDefinition; 1=referenceName; 2=functionName</comment>
  </data>
	<data name="variableNameIsInvalidFormat" xml:space="preserve">
    <value>Variable Name Field for variable "{0}" is invalid. Variable or function names must start with an alpha character or underscore and can contain only alphanumeric characters and underscores.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="arrayKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, each index in Member Name for variable {0}, must be an integer greater than or equal to zero.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="booleanKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be a boolean.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="byteKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type byte.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="charKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type char.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateTimeKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type DateTime.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateTimeOffsetKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type DateTimeOffset.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateOnlyKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type DateOnly.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="dateKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type Date.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="timeSpanKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type TimeSpan.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="timeOnlyKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type TimeOnly.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="timeOfDayKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type TimeOfDay.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="guidKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type Guid.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="decimalKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type decimal.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="doubleKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type double.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="floatKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type float.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="integerKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an integer.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="longKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type long.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="sbyteKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type sbyte.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="shortKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be of type short.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="uIntegerKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an unsigned integer.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="uLongKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an unsigned long integer.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="uShortKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be an unsigned short integer.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableKeyIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, Member Name for variable {0} must be a configured variable.</value>
    <comment>0=variableName</comment>
  </data>
	<data name="variableArrayIndexIsInvalidFormat" xml:space="preserve">
    <value>Given the variable category, each index in Member Name for variable {0} must be a configured integer variable or positive integer.</value>
    <comment>0=variableName</comment>
  </data>
</root>